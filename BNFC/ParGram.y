-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module ParGram where
import AbsGram
import LexGram
import ErrM

}

%name pProgram Program

-- no lexer declaration
%monad { Err } { thenM } { returnM }
%tokentype { Token }

%token 
 '&&' { PT _ (TS _ 1) }
 '(' { PT _ (TS _ 2) }
 ')' { PT _ (TS _ 3) }
 '*' { PT _ (TS _ 4) }
 '*=' { PT _ (TS _ 5) }
 '+' { PT _ (TS _ 6) }
 '++' { PT _ (TS _ 7) }
 '+=' { PT _ (TS _ 8) }
 ',' { PT _ (TS _ 9) }
 '-' { PT _ (TS _ 10) }
 '--' { PT _ (TS _ 11) }
 '-=' { PT _ (TS _ 12) }
 '/' { PT _ (TS _ 13) }
 '/=' { PT _ (TS _ 14) }
 ':' { PT _ (TS _ 15) }
 ';' { PT _ (TS _ 16) }
 '<' { PT _ (TS _ 17) }
 '=' { PT _ (TS _ 18) }
 '==' { PT _ (TS _ 19) }
 '>' { PT _ (TS _ 20) }
 '?' { PT _ (TS _ 21) }
 'as' { PT _ (TS _ 22) }
 'bool' { PT _ (TS _ 23) }
 'const' { PT _ (TS _ 24) }
 'do' { PT _ (TS _ 25) }
 'else' { PT _ (TS _ 26) }
 'else if (' { PT _ (TS _ 27) }
 'false' { PT _ (TS _ 28) }
 'from' { PT _ (TS _ 29) }
 'function' { PT _ (TS _ 30) }
 'guard' { PT _ (TS _ 31) }
 'if (' { PT _ (TS _ 32) }
 'in' { PT _ (TS _ 33) }
 'int' { PT _ (TS _ 34) }
 'is' { PT _ (TS _ 35) }
 'main' { PT _ (TS _ 36) }
 'print' { PT _ (TS _ 37) }
 'return' { PT _ (TS _ 38) }
 'to' { PT _ (TS _ 39) }
 'true' { PT _ (TS _ 40) }
 'type' { PT _ (TS _ 41) }
 'void' { PT _ (TS _ 42) }
 'while' { PT _ (TS _ 43) }
 '{' { PT _ (TS _ 44) }
 '||' { PT _ (TS _ 45) }
 '}' { PT _ (TS _ 46) }

L_ident  { PT _ (TV $$) }
L_integ  { PT _ (TI $$) }
L_err    { _ }


%%

Ident   :: { Ident }   : L_ident  { Ident $1 }
Integer :: { Integer } : L_integ  { (read ( $1)) :: Integer }

Program :: { Program }
Program : ListTypeDeclaration ListDecl ListFunctionDeclaration 'main' Block { Prog (reverse $1) (reverse $2) (reverse $3) $5 } 


Block :: { Block }
Block : '{' ListDecl ListStmt '}' { SBlock (reverse $2) (reverse $3) } 


RBlock :: { RBlock }
RBlock : '{' ListDecl ListStmt 'return' Expression ';' '}' { SRBlock (reverse $2) (reverse $3) $5 } 


Decl :: { Decl }
Decl : Type Identifier { Declr $1 $2 } 
  | Type Identifier '=' Expression { DAssign $1 $2 $4 }
  | 'const' Type Identifier '=' Expression { DConstDec $2 $3 $5 }


ListDecl :: { [Decl] }
ListDecl : {- empty -} { [] } 
  | ListDecl Decl ';' { flip (:) $1 $2 }


TypeDeclaration :: { TypeDeclaration }
TypeDeclaration : 'type' Identifier 'is' Type ';' { TDef $2 $4 } 


ListTypeDeclaration :: { [TypeDeclaration] }
ListTypeDeclaration : {- empty -} { [] } 
  | ListTypeDeclaration TypeDeclaration { flip (:) $1 $2 }


FunctionDeclaration :: { FunctionDeclaration }
FunctionDeclaration : 'function' Identifier '(' ListArguments ')' ':' Type RBlock { FDec $2 $4 $7 $8 } 
  | 'function' Identifier '(' ListArguments ')' ':' 'void' Block { PDec $2 $4 $8 }


ListFunctionDeclaration :: { [FunctionDeclaration] }
ListFunctionDeclaration : {- empty -} { [] } 
  | ListFunctionDeclaration FunctionDeclaration { flip (:) $1 $2 }


CallArgs :: { CallArgs }
CallArgs : Expression { Cargs $1 } 


Arguments :: { Arguments }
Arguments : Type Identifier { Args $1 $2 } 


ListCallArgs :: { [CallArgs] }
ListCallArgs : {- empty -} { [] } 
  | CallArgs { (:[]) $1 }
  | CallArgs ',' ListCallArgs { (:) $1 $3 }


ListArguments :: { [Arguments] }
ListArguments : {- empty -} { [] } 
  | Arguments { (:[]) $1 }
  | Arguments ',' ListArguments { (:) $1 $3 }


Stmt :: { Stmt }
Stmt : Assignment ';' { SAssign $1 } 
  | Expression ';' { SExp $1 }
  | 'while' '(' Exp ')' Block { SWhile $3 $5 }
  | 'from' Exp 'to' Exp 'as' Ident 'do' Block { SFor $2 $4 $6 $8 }
  | 'guard' '(' ListIdentifier ')' 'in' Block { SGuard $3 $6 }
  | 'print' '(' Exp ')' ';' { Sprint $3 }
  | If { SIf $1 }
  | If 'else' Block { SIfE $1 $3 }


ListStmt :: { [Stmt] }
ListStmt : {- empty -} { [] } 
  | ListStmt Stmt { flip (:) $1 $2 }


If :: { If }
If : 'if (' Exp ')' Block ListEIf { If $2 $4 (reverse $5) } 


EIf :: { EIf }
EIf : 'else if (' Exp ')' Block { SEIf $2 $4 } 


ListEIf :: { [EIf] }
ListEIf : {- empty -} { [] } 
  | ListEIf EIf { flip (:) $1 $2 }


Expression :: { Expression }
Expression : Exp { Exp $1 } 
  | Exp '?' Exp ':' Exp { ExpTer $1 $3 $5 }


Exp :: { Exp }
Exp : Exp '||' Exp1 { Eor $1 $3 } 
  | Exp '&&' Exp1 { Eand $1 $3 }
  | Exp1 { $1 }


Exp1 :: { Exp }
Exp1 : Exp1 '==' Exp2 { Eeq $1 $3 } 
  | Exp2 { $1 }


Exp2 :: { Exp }
Exp2 : Exp2 '<' Exp3 { Elt $1 $3 } 
  | Exp2 '>' Exp3 { Egt $1 $3 }
  | Exp3 { $1 }


Exp3 :: { Exp }
Exp3 : Exp3 '+' Exp4 { EAdd $1 $3 } 
  | Exp3 '-' Exp4 { ESub $1 $3 }
  | Exp4 { $1 }


Exp4 :: { Exp }
Exp4 : Exp4 '*' Exp5 { EMul $1 $3 } 
  | Exp4 '/' Exp5 { EDiv $1 $3 }
  | Exp5 { $1 }


Exp5 :: { Exp }
Exp5 : '-' Exp6 { EMinus $2 } 
  | Exp6 { $1 }


Exp6 :: { Exp }
Exp6 : Identifier '(' ListCallArgs ')' { Call $1 $3 } 
  | Identifier { EVar $1 }
  | Integer { EInt $1 }
  | 'true' { Etrue }
  | 'false' { Efalse }
  | '(' Exp ')' { $2 }


Assignment :: { Assignment }
Assignment : Identifier '=' Expression { Assign $1 $3 } 
  | Identifier ArAssign Expression { AArith $1 $2 $3 }
  | Identifier IncDec { AIncDec $1 $2 }


Type :: { Type }
Type : 'int' { TInt } 
  | 'bool' { TBool }


Identifier :: { Identifier }
Identifier : Ident { Id $1 } 


ListIdentifier :: { [Identifier] }
ListIdentifier : Identifier { (:[]) $1 } 
  | Identifier ',' ListIdentifier { (:) $1 $3 }


ArAssign :: { ArAssign }
ArAssign : '+=' { AAPlus } 
  | '-=' { AAMinus }
  | '*=' { AAMulti }
  | '/=' { AADiv }


IncDec :: { IncDec }
IncDec : '++' { Increment } 
  | '--' { Decrement }



{

returnM :: a -> Err a
returnM = return

thenM :: Err a -> (a -> Err b) -> Err b
thenM = (>>=)

happyError :: [Token] -> Err a
happyError ts =
  Bad $ "syntax error at " ++ tokenPos ts ++ 
  case ts of
    [] -> []
    [Err _] -> " due to lexer error"
    _ -> " before " ++ unwords (map (id . prToken) (take 4 ts))

myLexer = tokens
}

