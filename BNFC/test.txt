-----------------------------------------------------------------------------
Info file generated by Happy Version 1.19.2 from ParGram.y
-----------------------------------------------------------------------------

state 5 contains 2 shift/reduce conflicts.
state 36 contains 3 reduce/reduce conflicts.
state 44 contains 3 reduce/reduce conflicts.
state 57 contains 1 reduce/reduce conflicts.
state 63 contains 1 reduce/reduce conflicts.

rule 36 is unused
rule 72 is unused
rule 73 is unused
rule 74 is unused
rule 75 is unused
rule 76 is unused
rule 77 is unused

terminal L_err is unused

-----------------------------------------------------------------------------
Grammar
-----------------------------------------------------------------------------
	%start_pProgram -> Program                         (0)
	Integer -> L_integ                                 (1)
	Ident -> L_ident                                   (2)
	Program -> ListTypeDeclaration ListDecl ListFunctionDeclaration 'main' Block   (3)
	Block -> '{' ListStatement '}'                     (4)
	RBlock -> '{' ListStatement 'return' Expression ';' '}'   (5)
	Decl -> Type Identifier ';'                        (6)
	Decl -> Type Identifier '=' Expression ';'         (7)
	Decl -> 'const' Type Identifier '=' Expression ';'   (8)
	ListDecl ->                                        (9)
	ListDecl -> ListDecl Decl                          (10)
	TypeDeclaration -> 'type' Identifier 'is' Type ';'   (11)
	ListTypeDeclaration ->                             (12)
	ListTypeDeclaration -> ListTypeDeclaration TypeDeclaration   (13)
	FunctionDeclaration -> FunDec                      (14)
	FunctionDeclaration -> ProcDec                     (15)
	ListFunctionDeclaration ->                         (16)
	ListFunctionDeclaration -> ListFunctionDeclaration FunctionDeclaration   (17)
	FunDec -> Type Identifier '(' ListArguments ')' RBlock   (18)
	ProcDec -> 'void' Identifier '(' ListArguments ')' Block   (19)
	FunctionCall -> Identifier '(' ListCallArgs ')'    (20)
	CallArgs -> Expression                             (21)
	Arguments -> Type Identifier                       (22)
	ListCallArgs ->                                    (23)
	ListCallArgs -> CallArgs                           (24)
	ListCallArgs -> CallArgs ',' ListCallArgs          (25)
	ListArguments ->                                   (26)
	ListArguments -> Arguments                         (27)
	ListArguments -> Arguments ',' ListArguments       (28)
	Statement -> St ';'                                (29)
	Statement -> Stt                                   (30)
	ListStatement ->                                   (31)
	ListStatement -> ListStatement Statement           (32)
	St -> Decl                                         (33)
	St -> Assignment                                   (34)
	St -> Expression                                   (35)
	St -> FunctionCall                                 (36)
	Stt -> 'while' '(' BExp ')' Block                  (37)
	Stt -> 'for' '(' Decl ';' BExp ';' Assignment ')' Block   (38)
	Stt -> 'guard' '(' ListIdentifier ')' 'in' Block   (39)
	Stt -> 'if (' BExp ')' Block ListEIf 'else' Block   (40)
	EIf -> 'else if (' BExp ')' Block                  (41)
	ListEIf ->                                         (42)
	ListEIf -> ListEIf EIf                             (43)
	ListIdentifier ->                                  (44)
	ListIdentifier -> Identifier                       (45)
	ListIdentifier -> Identifier ',' ListIdentifier    (46)
	Expression -> Exp                                  (47)
	Expression -> BExp                                 (48)
	Exp -> Exp '+' Exp1                                (49)
	Exp -> Exp '-' Exp1                                (50)
	Exp -> Exp1                                        (51)
	Exp1 -> Exp1 '*' Exp2                              (52)
	Exp1 -> Exp1 '/' Exp2                              (53)
	Exp1 -> Exp2                                       (54)
	Exp2 -> FunctionCall                               (55)
	Exp2 -> Identifier                                 (56)
	Exp2 -> Integer                                    (57)
	Exp2 -> '(' Exp ')'                                (58)
	BExp -> '(' BExp ')' LogicalOperator '(' BExp ')'   (59)
	BExp -> BExp1                                      (60)
	BExp1 -> 'not' '(' BExp ')'                        (61)
	BExp1 -> Exp ComparisonOperator Exp                (62)
	BExp1 -> BExp2                                     (63)
	BExp2 -> FunctionCall                              (64)
	BExp2 -> Identifier                                (65)
	BExp2 -> 'true'                                    (66)
	BExp2 -> 'false'                                   (67)
	BExp2 -> '(' BExp ')'                              (68)
	Assignment -> Identifier '=' Expression            (69)
	Assignment -> Identifier ArAssign Expression       (70)
	Assignment -> Identifier IncDec                    (71)
	Value -> 'true'                                    (72)
	Value -> 'false'                                   (73)
	Value -> Integer                                   (74)
	Value -> Identifier                                (75)
	Value -> Expression                                (76)
	Value -> FunctionCall                              (77)
	Type -> 'int'                                      (78)
	Type -> 'bool'                                     (79)
	Identifier -> Ident                                (80)
	ArAssign -> '+='                                   (81)
	ArAssign -> '-='                                   (82)
	ArAssign -> '*='                                   (83)
	ArAssign -> '/='                                   (84)
	IncDec -> '++'                                     (85)
	IncDec -> '--'                                     (86)
	ComparisonOperator -> '>'                          (87)
	ComparisonOperator -> '<'                          (88)
	ComparisonOperator -> '=='                         (89)
	LogicalOperator -> '&&'                            (90)
	LogicalOperator -> '||'                            (91)

-----------------------------------------------------------------------------
Terminals
-----------------------------------------------------------------------------
	'&&'           { PT _ (TS _ 1) }
	'('            { PT _ (TS _ 2) }
	')'            { PT _ (TS _ 3) }
	'*'            { PT _ (TS _ 4) }
	'*='           { PT _ (TS _ 5) }
	'+'            { PT _ (TS _ 6) }
	'++'           { PT _ (TS _ 7) }
	'+='           { PT _ (TS _ 8) }
	','            { PT _ (TS _ 9) }
	'-'            { PT _ (TS _ 10) }
	'--'           { PT _ (TS _ 11) }
	'-='           { PT _ (TS _ 12) }
	'/'            { PT _ (TS _ 13) }
	'/='           { PT _ (TS _ 14) }
	';'            { PT _ (TS _ 15) }
	'<'            { PT _ (TS _ 16) }
	'='            { PT _ (TS _ 17) }
	'=='           { PT _ (TS _ 18) }
	'>'            { PT _ (TS _ 19) }
	'bool'         { PT _ (TS _ 20) }
	'const'        { PT _ (TS _ 21) }
	'else'         { PT _ (TS _ 22) }
	'else if ('    { PT _ (TS _ 23) }
	'false'        { PT _ (TS _ 24) }
	'for'          { PT _ (TS _ 25) }
	'guard'        { PT _ (TS _ 26) }
	'if ('         { PT _ (TS _ 27) }
	'in'           { PT _ (TS _ 28) }
	'int'          { PT _ (TS _ 29) }
	'is'           { PT _ (TS _ 30) }
	'main'         { PT _ (TS _ 31) }
	'not'          { PT _ (TS _ 32) }
	'return'       { PT _ (TS _ 33) }
	'true'         { PT _ (TS _ 34) }
	'type'         { PT _ (TS _ 35) }
	'void'         { PT _ (TS _ 36) }
	'while'        { PT _ (TS _ 37) }
	'{'            { PT _ (TS _ 38) }
	'||'           { PT _ (TS _ 39) }
	'}'            { PT _ (TS _ 40) }
	L_integ        { PT _ (TI $$) }
	L_ident        { PT _ (TV $$) }
	L_err          { _ }

-----------------------------------------------------------------------------
Non-terminals
-----------------------------------------------------------------------------
	%start_pProgram rule  0
	Integer         rule  1
	Ident           rule  2
	Program         rule  3
	Block           rule  4
	RBlock          rule  5
	Decl            rules 6, 7, 8
	ListDecl        rules 9, 10
	TypeDeclaration rule  11
	ListTypeDeclaration rules 12, 13
	FunctionDeclaration rules 14, 15
	ListFunctionDeclaration rules 16, 17
	FunDec          rule  18
	ProcDec         rule  19
	FunctionCall    rule  20
	CallArgs        rule  21
	Arguments       rule  22
	ListCallArgs    rules 23, 24, 25
	ListArguments   rules 26, 27, 28
	Statement       rules 29, 30
	ListStatement   rules 31, 32
	St              rules 33, 34, 35, 36
	Stt             rules 37, 38, 39, 40
	EIf             rule  41
	ListEIf         rules 42, 43
	ListIdentifier  rules 44, 45, 46
	Expression      rules 47, 48
	Exp             rules 49, 50, 51
	Exp1            rules 52, 53, 54
	Exp2            rules 55, 56, 57, 58
	BExp            rules 59, 60
	BExp1           rules 61, 62, 63
	BExp2           rules 64, 65, 66, 67, 68
	Assignment      rules 69, 70, 71
	Value           rules 72, 73, 74, 75, 76, 77
	Type            rules 78, 79
	Identifier      rule  80
	ArAssign        rules 81, 82, 83, 84
	IncDec          rules 85, 86
	ComparisonOperator rules 87, 88, 89
	LogicalOperator rules 90, 91

-----------------------------------------------------------------------------
States
-----------------------------------------------------------------------------
State 0


	'bool'         reduce using rule 12
	'const'        reduce using rule 12
	'int'          reduce using rule 12
	'main'         reduce using rule 12
	'type'         reduce using rule 12
	'void'         reduce using rule 12

	Program        goto state 3
	ListTypeDeclarationgoto state 4

State 1


	L_integ        shift, and enter state 2


State 2

	Integer -> L_integ .                                (rule 1)

	')'            reduce using rule 1
	'*'            reduce using rule 1
	'+'            reduce using rule 1
	','            reduce using rule 1
	'-'            reduce using rule 1
	'/'            reduce using rule 1
	';'            reduce using rule 1
	'<'            reduce using rule 1
	'=='           reduce using rule 1
	'>'            reduce using rule 1


State 3

	%start_pProgram -> Program .                        (rule 0)

	%eof           accept


State 4

	Program -> ListTypeDeclaration . ListDecl ListFunctionDeclaration 'main' Block    (rule 3)
	ListTypeDeclaration -> ListTypeDeclaration . TypeDeclaration    (rule 13)

	'bool'         reduce using rule 9
	'const'        reduce using rule 9
	'int'          reduce using rule 9
	'main'         reduce using rule 9
	'type'         shift, and enter state 7
	'void'         reduce using rule 9

	ListDecl       goto state 5
	TypeDeclarationgoto state 6

State 5

	Program -> ListTypeDeclaration ListDecl . ListFunctionDeclaration 'main' Block    (rule 3)
	ListDecl -> ListDecl . Decl                         (rule 10)

	'bool'         shift, and enter state 14
			(reduce using rule 16)

	'const'        shift, and enter state 15
	'int'          shift, and enter state 16
			(reduce using rule 16)

	'main'         reduce using rule 16
	'void'         reduce using rule 16

	Decl           goto state 11
	ListFunctionDeclarationgoto state 12
	Type           goto state 13

State 6

	ListTypeDeclaration -> ListTypeDeclaration TypeDeclaration .    (rule 13)

	'bool'         reduce using rule 13
	'const'        reduce using rule 13
	'int'          reduce using rule 13
	'main'         reduce using rule 13
	'type'         reduce using rule 13
	'void'         reduce using rule 13


State 7

	TypeDeclaration -> 'type' . Identifier 'is' Type ';'    (rule 11)

	L_ident        shift, and enter state 10

	Ident          goto state 8
	Identifier     goto state 9

State 8

	Identifier -> Ident .                               (rule 80)

	'('            reduce using rule 80
	')'            reduce using rule 80
	'*'            reduce using rule 80
	'*='           reduce using rule 80
	'+'            reduce using rule 80
	'++'           reduce using rule 80
	'+='           reduce using rule 80
	','            reduce using rule 80
	'-'            reduce using rule 80
	'--'           reduce using rule 80
	'-='           reduce using rule 80
	'/'            reduce using rule 80
	'/='           reduce using rule 80
	';'            reduce using rule 80
	'<'            reduce using rule 80
	'='            reduce using rule 80
	'=='           reduce using rule 80
	'>'            reduce using rule 80
	'is'           reduce using rule 80


State 9

	TypeDeclaration -> 'type' Identifier . 'is' Type ';'    (rule 11)

	'is'           shift, and enter state 25


State 10

	Ident -> L_ident .                                  (rule 2)

	'('            reduce using rule 2
	')'            reduce using rule 2
	'*'            reduce using rule 2
	'*='           reduce using rule 2
	'+'            reduce using rule 2
	'++'           reduce using rule 2
	'+='           reduce using rule 2
	','            reduce using rule 2
	'-'            reduce using rule 2
	'--'           reduce using rule 2
	'-='           reduce using rule 2
	'/'            reduce using rule 2
	'/='           reduce using rule 2
	';'            reduce using rule 2
	'<'            reduce using rule 2
	'='            reduce using rule 2
	'=='           reduce using rule 2
	'>'            reduce using rule 2
	'is'           reduce using rule 2


State 11

	ListDecl -> ListDecl Decl .                         (rule 10)

	'bool'         reduce using rule 10
	'const'        reduce using rule 10
	'int'          reduce using rule 10
	'main'         reduce using rule 10
	'void'         reduce using rule 10


State 12

	Program -> ListTypeDeclaration ListDecl ListFunctionDeclaration . 'main' Block    (rule 3)
	ListFunctionDeclaration -> ListFunctionDeclaration . FunctionDeclaration    (rule 17)

	'bool'         shift, and enter state 14
	'int'          shift, and enter state 16
	'main'         shift, and enter state 23
	'void'         shift, and enter state 24

	FunctionDeclarationgoto state 19
	FunDec         goto state 20
	ProcDec        goto state 21
	Type           goto state 22

State 13

	Decl -> Type . Identifier ';'                       (rule 6)
	Decl -> Type . Identifier '=' Expression ';'        (rule 7)

	L_ident        shift, and enter state 10

	Ident          goto state 8
	Identifier     goto state 18

State 14

	Type -> 'bool' .                                    (rule 79)

	';'            reduce using rule 79
	L_ident        reduce using rule 79


State 15

	Decl -> 'const' . Type Identifier '=' Expression ';'    (rule 8)

	'bool'         shift, and enter state 14
	'int'          shift, and enter state 16

	Type           goto state 17

State 16

	Type -> 'int' .                                     (rule 78)

	';'            reduce using rule 78
	L_ident        reduce using rule 78


State 17

	Decl -> 'const' Type . Identifier '=' Expression ';'    (rule 8)

	L_ident        shift, and enter state 10

	Ident          goto state 8
	Identifier     goto state 33

State 18

	Decl -> Type Identifier . ';'                       (rule 6)
	Decl -> Type Identifier . '=' Expression ';'        (rule 7)

	';'            shift, and enter state 31
	'='            shift, and enter state 32


State 19

	ListFunctionDeclaration -> ListFunctionDeclaration FunctionDeclaration .    (rule 17)

	'bool'         reduce using rule 17
	'int'          reduce using rule 17
	'main'         reduce using rule 17
	'void'         reduce using rule 17


State 20

	FunctionDeclaration -> FunDec .                     (rule 14)

	'bool'         reduce using rule 14
	'int'          reduce using rule 14
	'main'         reduce using rule 14
	'void'         reduce using rule 14


State 21

	FunctionDeclaration -> ProcDec .                    (rule 15)

	'bool'         reduce using rule 15
	'int'          reduce using rule 15
	'main'         reduce using rule 15
	'void'         reduce using rule 15


State 22

	FunDec -> Type . Identifier '(' ListArguments ')' RBlock    (rule 18)

	L_ident        shift, and enter state 10

	Ident          goto state 8
	Identifier     goto state 30

State 23

	Program -> ListTypeDeclaration ListDecl ListFunctionDeclaration 'main' . Block    (rule 3)

	'{'            shift, and enter state 29

	Block          goto state 28

State 24

	ProcDec -> 'void' . Identifier '(' ListArguments ')' Block    (rule 19)

	L_ident        shift, and enter state 10

	Ident          goto state 8
	Identifier     goto state 27

State 25

	TypeDeclaration -> 'type' Identifier 'is' . Type ';'    (rule 11)

	'bool'         shift, and enter state 14
	'int'          shift, and enter state 16

	Type           goto state 26

State 26

	TypeDeclaration -> 'type' Identifier 'is' Type . ';'    (rule 11)

	';'            shift, and enter state 52


State 27

	ProcDec -> 'void' Identifier . '(' ListArguments ')' Block    (rule 19)

	'('            shift, and enter state 51


State 28

	Program -> ListTypeDeclaration ListDecl ListFunctionDeclaration 'main' Block .    (rule 3)

	%eof           reduce using rule 3


State 29

	Block -> '{' . ListStatement '}'                    (rule 4)

	'('            reduce using rule 31
	'bool'         reduce using rule 31
	'const'        reduce using rule 31
	'false'        reduce using rule 31
	'for'          reduce using rule 31
	'guard'        reduce using rule 31
	'if ('         reduce using rule 31
	'int'          reduce using rule 31
	'not'          reduce using rule 31
	'true'         reduce using rule 31
	'while'        reduce using rule 31
	'}'            reduce using rule 31
	L_integ        reduce using rule 31
	L_ident        reduce using rule 31

	ListStatement  goto state 50

State 30

	FunDec -> Type Identifier . '(' ListArguments ')' RBlock    (rule 18)

	'('            shift, and enter state 49


State 31

	Decl -> Type Identifier ';' .                       (rule 6)

	';'            reduce using rule 6
	'bool'         reduce using rule 6
	'const'        reduce using rule 6
	'int'          reduce using rule 6
	'main'         reduce using rule 6
	'void'         reduce using rule 6


State 32

	Decl -> Type Identifier '=' . Expression ';'        (rule 7)

	'('            shift, and enter state 45
	'false'        shift, and enter state 46
	'not'          shift, and enter state 47
	'true'         shift, and enter state 48
	L_integ        shift, and enter state 2
	L_ident        shift, and enter state 10

	Integer        goto state 35
	Ident          goto state 8
	FunctionCall   goto state 36
	Expression     goto state 37
	Exp            goto state 38
	Exp1           goto state 39
	Exp2           goto state 40
	BExp           goto state 41
	BExp1          goto state 42
	BExp2          goto state 43
	Identifier     goto state 44

State 33

	Decl -> 'const' Type Identifier . '=' Expression ';'    (rule 8)

	'='            shift, and enter state 34


State 34

	Decl -> 'const' Type Identifier '=' . Expression ';'    (rule 8)

	'('            shift, and enter state 45
	'false'        shift, and enter state 46
	'not'          shift, and enter state 47
	'true'         shift, and enter state 48
	L_integ        shift, and enter state 2
	L_ident        shift, and enter state 10

	Integer        goto state 35
	Ident          goto state 8
	FunctionCall   goto state 36
	Expression     goto state 83
	Exp            goto state 38
	Exp1           goto state 39
	Exp2           goto state 40
	BExp           goto state 41
	BExp1          goto state 42
	BExp2          goto state 43
	Identifier     goto state 44

State 35

	Exp2 -> Integer .                                   (rule 57)

	')'            reduce using rule 57
	'*'            reduce using rule 57
	'+'            reduce using rule 57
	','            reduce using rule 57
	'-'            reduce using rule 57
	'/'            reduce using rule 57
	';'            reduce using rule 57
	'<'            reduce using rule 57
	'=='           reduce using rule 57
	'>'            reduce using rule 57


State 36

	Exp2 -> FunctionCall .                              (rule 55)
	BExp2 -> FunctionCall .                             (rule 64)

	')'            reduce using rule 64
			(reduce using rule 55)

	'*'            reduce using rule 55
	'+'            reduce using rule 55
	','            reduce using rule 64
			(reduce using rule 55)

	'-'            reduce using rule 55
	'/'            reduce using rule 55
	';'            reduce using rule 64
			(reduce using rule 55)

	'<'            reduce using rule 55
	'=='           reduce using rule 55
	'>'            reduce using rule 55


State 37

	Decl -> Type Identifier '=' Expression . ';'        (rule 7)

	';'            shift, and enter state 82


State 38

	Expression -> Exp .                                 (rule 47)
	Exp -> Exp . '+' Exp1                               (rule 49)
	Exp -> Exp . '-' Exp1                               (rule 50)
	BExp1 -> Exp . ComparisonOperator Exp               (rule 62)

	')'            reduce using rule 47
	'+'            shift, and enter state 77
	','            reduce using rule 47
	'-'            shift, and enter state 78
	';'            reduce using rule 47
	'<'            shift, and enter state 79
	'=='           shift, and enter state 80
	'>'            shift, and enter state 81

	ComparisonOperatorgoto state 76

State 39

	Exp -> Exp1 .                                       (rule 51)
	Exp1 -> Exp1 . '*' Exp2                             (rule 52)
	Exp1 -> Exp1 . '/' Exp2                             (rule 53)

	')'            reduce using rule 51
	'*'            shift, and enter state 74
	'+'            reduce using rule 51
	','            reduce using rule 51
	'-'            reduce using rule 51
	'/'            shift, and enter state 75
	';'            reduce using rule 51
	'<'            reduce using rule 51
	'=='           reduce using rule 51
	'>'            reduce using rule 51


State 40

	Exp1 -> Exp2 .                                      (rule 54)

	')'            reduce using rule 54
	'*'            reduce using rule 54
	'+'            reduce using rule 54
	','            reduce using rule 54
	'-'            reduce using rule 54
	'/'            reduce using rule 54
	';'            reduce using rule 54
	'<'            reduce using rule 54
	'=='           reduce using rule 54
	'>'            reduce using rule 54


State 41

	Expression -> BExp .                                (rule 48)

	')'            reduce using rule 48
	','            reduce using rule 48
	';'            reduce using rule 48


State 42

	BExp -> BExp1 .                                     (rule 60)

	')'            reduce using rule 60
	','            reduce using rule 60
	';'            reduce using rule 60


State 43

	BExp1 -> BExp2 .                                    (rule 63)

	')'            reduce using rule 63
	','            reduce using rule 63
	';'            reduce using rule 63


State 44

	FunctionCall -> Identifier . '(' ListCallArgs ')'    (rule 20)
	Exp2 -> Identifier .                                (rule 56)
	BExp2 -> Identifier .                               (rule 65)

	'('            shift, and enter state 73
	')'            reduce using rule 65
			(reduce using rule 56)

	'*'            reduce using rule 56
	'+'            reduce using rule 56
	','            reduce using rule 65
			(reduce using rule 56)

	'-'            reduce using rule 56
	'/'            reduce using rule 56
	';'            reduce using rule 65
			(reduce using rule 56)

	'<'            reduce using rule 56
	'=='           reduce using rule 56
	'>'            reduce using rule 56


State 45

	Exp2 -> '(' . Exp ')'                               (rule 58)
	BExp -> '(' . BExp ')' LogicalOperator '(' BExp ')'    (rule 59)
	BExp2 -> '(' . BExp ')'                             (rule 68)

	'('            shift, and enter state 45
	'false'        shift, and enter state 46
	'not'          shift, and enter state 47
	'true'         shift, and enter state 48
	L_integ        shift, and enter state 2
	L_ident        shift, and enter state 10

	Integer        goto state 35
	Ident          goto state 8
	FunctionCall   goto state 36
	Exp            goto state 71
	Exp1           goto state 39
	Exp2           goto state 40
	BExp           goto state 72
	BExp1          goto state 42
	BExp2          goto state 43
	Identifier     goto state 44

State 46

	BExp2 -> 'false' .                                  (rule 67)

	')'            reduce using rule 67
	','            reduce using rule 67
	';'            reduce using rule 67


State 47

	BExp1 -> 'not' . '(' BExp ')'                       (rule 61)

	'('            shift, and enter state 70


State 48

	BExp2 -> 'true' .                                   (rule 66)

	')'            reduce using rule 66
	','            reduce using rule 66
	';'            reduce using rule 66


State 49

	FunDec -> Type Identifier '(' . ListArguments ')' RBlock    (rule 18)

	')'            reduce using rule 26
	'bool'         shift, and enter state 14
	'int'          shift, and enter state 16

	Arguments      goto state 53
	ListArguments  goto state 69
	Type           goto state 55

State 50

	Block -> '{' ListStatement . '}'                    (rule 4)
	ListStatement -> ListStatement . Statement          (rule 32)

	'('            shift, and enter state 45
	'bool'         shift, and enter state 14
	'const'        shift, and enter state 15
	'false'        shift, and enter state 46
	'for'          shift, and enter state 64
	'guard'        shift, and enter state 65
	'if ('         shift, and enter state 66
	'int'          shift, and enter state 16
	'not'          shift, and enter state 47
	'true'         shift, and enter state 48
	'while'        shift, and enter state 67
	'}'            shift, and enter state 68
	L_integ        shift, and enter state 2
	L_ident        shift, and enter state 10

	Integer        goto state 35
	Ident          goto state 8
	Decl           goto state 56
	FunctionCall   goto state 57
	Statement      goto state 58
	St             goto state 59
	Stt            goto state 60
	Expression     goto state 61
	Exp            goto state 38
	Exp1           goto state 39
	Exp2           goto state 40
	BExp           goto state 41
	BExp1          goto state 42
	BExp2          goto state 43
	Assignment     goto state 62
	Type           goto state 13
	Identifier     goto state 63

State 51

	ProcDec -> 'void' Identifier '(' . ListArguments ')' Block    (rule 19)

	')'            reduce using rule 26
	'bool'         shift, and enter state 14
	'int'          shift, and enter state 16

	Arguments      goto state 53
	ListArguments  goto state 54
	Type           goto state 55

State 52

	TypeDeclaration -> 'type' Identifier 'is' Type ';' .    (rule 11)

	'bool'         reduce using rule 11
	'const'        reduce using rule 11
	'int'          reduce using rule 11
	'main'         reduce using rule 11
	'type'         reduce using rule 11
	'void'         reduce using rule 11


State 53

	ListArguments -> Arguments .                        (rule 27)
	ListArguments -> Arguments . ',' ListArguments      (rule 28)

	')'            reduce using rule 27
	','            shift, and enter state 117


State 54

	ProcDec -> 'void' Identifier '(' ListArguments . ')' Block    (rule 19)

	')'            shift, and enter state 116


State 55

	Arguments -> Type . Identifier                      (rule 22)

	L_ident        shift, and enter state 10

	Ident          goto state 8
	Identifier     goto state 115

State 56

	St -> Decl .                                        (rule 33)

	';'            reduce using rule 33


State 57

	St -> FunctionCall .                                (rule 36)
	Exp2 -> FunctionCall .                              (rule 55)
	BExp2 -> FunctionCall .                             (rule 64)

	'*'            reduce using rule 55
	'+'            reduce using rule 55
	'-'            reduce using rule 55
	'/'            reduce using rule 55
	';'            reduce using rule 64
			(reduce using rule 55)
			(reduce using rule 36)

	'<'            reduce using rule 55
	'=='           reduce using rule 55
	'>'            reduce using rule 55


State 58

	ListStatement -> ListStatement Statement .          (rule 32)

	'('            reduce using rule 32
	'bool'         reduce using rule 32
	'const'        reduce using rule 32
	'false'        reduce using rule 32
	'for'          reduce using rule 32
	'guard'        reduce using rule 32
	'if ('         reduce using rule 32
	'int'          reduce using rule 32
	'not'          reduce using rule 32
	'return'       reduce using rule 32
	'true'         reduce using rule 32
	'while'        reduce using rule 32
	'}'            reduce using rule 32
	L_integ        reduce using rule 32
	L_ident        reduce using rule 32


State 59

	Statement -> St . ';'                               (rule 29)

	';'            shift, and enter state 114


State 60

	Statement -> Stt .                                  (rule 30)

	'('            reduce using rule 30
	'bool'         reduce using rule 30
	'const'        reduce using rule 30
	'false'        reduce using rule 30
	'for'          reduce using rule 30
	'guard'        reduce using rule 30
	'if ('         reduce using rule 30
	'int'          reduce using rule 30
	'not'          reduce using rule 30
	'return'       reduce using rule 30
	'true'         reduce using rule 30
	'while'        reduce using rule 30
	'}'            reduce using rule 30
	L_integ        reduce using rule 30
	L_ident        reduce using rule 30


State 61

	St -> Expression .                                  (rule 35)

	';'            reduce using rule 35


State 62

	St -> Assignment .                                  (rule 34)

	';'            reduce using rule 34


State 63

	FunctionCall -> Identifier . '(' ListCallArgs ')'    (rule 20)
	Exp2 -> Identifier .                                (rule 56)
	BExp2 -> Identifier .                               (rule 65)
	Assignment -> Identifier . '=' Expression           (rule 69)
	Assignment -> Identifier . ArAssign Expression      (rule 70)
	Assignment -> Identifier . IncDec                   (rule 71)

	'('            shift, and enter state 73
	'*'            reduce using rule 56
	'*='           shift, and enter state 107
	'+'            reduce using rule 56
	'++'           shift, and enter state 108
	'+='           shift, and enter state 109
	'-'            reduce using rule 56
	'--'           shift, and enter state 110
	'-='           shift, and enter state 111
	'/'            reduce using rule 56
	'/='           shift, and enter state 112
	';'            reduce using rule 65
			(reduce using rule 56)

	'<'            reduce using rule 56
	'='            shift, and enter state 113
	'=='           reduce using rule 56
	'>'            reduce using rule 56

	ArAssign       goto state 105
	IncDec         goto state 106

State 64

	Stt -> 'for' . '(' Decl ';' BExp ';' Assignment ')' Block    (rule 38)

	'('            shift, and enter state 104


State 65

	Stt -> 'guard' . '(' ListIdentifier ')' 'in' Block    (rule 39)

	'('            shift, and enter state 103


State 66

	Stt -> 'if (' . BExp ')' Block ListEIf 'else' Block    (rule 40)

	'('            shift, and enter state 45
	'false'        shift, and enter state 46
	'not'          shift, and enter state 47
	'true'         shift, and enter state 48
	L_integ        shift, and enter state 2
	L_ident        shift, and enter state 10

	Integer        goto state 35
	Ident          goto state 8
	FunctionCall   goto state 36
	Exp            goto state 98
	Exp1           goto state 39
	Exp2           goto state 40
	BExp           goto state 102
	BExp1          goto state 42
	BExp2          goto state 43
	Identifier     goto state 44

State 67

	Stt -> 'while' . '(' BExp ')' Block                 (rule 37)

	'('            shift, and enter state 101


State 68

	Block -> '{' ListStatement '}' .                    (rule 4)

	'('            reduce using rule 4
	'bool'         reduce using rule 4
	'const'        reduce using rule 4
	'else'         reduce using rule 4
	'else if ('    reduce using rule 4
	'false'        reduce using rule 4
	'for'          reduce using rule 4
	'guard'        reduce using rule 4
	'if ('         reduce using rule 4
	'int'          reduce using rule 4
	'main'         reduce using rule 4
	'not'          reduce using rule 4
	'return'       reduce using rule 4
	'true'         reduce using rule 4
	'void'         reduce using rule 4
	'while'        reduce using rule 4
	'}'            reduce using rule 4
	L_integ        reduce using rule 4
	L_ident        reduce using rule 4
	%eof           reduce using rule 4


State 69

	FunDec -> Type Identifier '(' ListArguments . ')' RBlock    (rule 18)

	')'            shift, and enter state 100


State 70

	BExp1 -> 'not' '(' . BExp ')'                       (rule 61)

	'('            shift, and enter state 45
	'false'        shift, and enter state 46
	'not'          shift, and enter state 47
	'true'         shift, and enter state 48
	L_integ        shift, and enter state 2
	L_ident        shift, and enter state 10

	Integer        goto state 35
	Ident          goto state 8
	FunctionCall   goto state 36
	Exp            goto state 98
	Exp1           goto state 39
	Exp2           goto state 40
	BExp           goto state 99
	BExp1          goto state 42
	BExp2          goto state 43
	Identifier     goto state 44

State 71

	Exp -> Exp . '+' Exp1                               (rule 49)
	Exp -> Exp . '-' Exp1                               (rule 50)
	Exp2 -> '(' Exp . ')'                               (rule 58)
	BExp1 -> Exp . ComparisonOperator Exp               (rule 62)

	')'            shift, and enter state 97
	'+'            shift, and enter state 77
	'-'            shift, and enter state 78
	'<'            shift, and enter state 79
	'=='           shift, and enter state 80
	'>'            shift, and enter state 81

	ComparisonOperatorgoto state 76

State 72

	BExp -> '(' BExp . ')' LogicalOperator '(' BExp ')'    (rule 59)
	BExp2 -> '(' BExp . ')'                             (rule 68)

	')'            shift, and enter state 96


State 73

	FunctionCall -> Identifier '(' . ListCallArgs ')'    (rule 20)

	'('            shift, and enter state 45
	')'            reduce using rule 23
	'false'        shift, and enter state 46
	'not'          shift, and enter state 47
	'true'         shift, and enter state 48
	L_integ        shift, and enter state 2
	L_ident        shift, and enter state 10

	Integer        goto state 35
	Ident          goto state 8
	FunctionCall   goto state 36
	CallArgs       goto state 93
	ListCallArgs   goto state 94
	Expression     goto state 95
	Exp            goto state 38
	Exp1           goto state 39
	Exp2           goto state 40
	BExp           goto state 41
	BExp1          goto state 42
	BExp2          goto state 43
	Identifier     goto state 44

State 74

	Exp1 -> Exp1 '*' . Exp2                             (rule 52)

	'('            shift, and enter state 88
	L_integ        shift, and enter state 2
	L_ident        shift, and enter state 10

	Integer        goto state 35
	Ident          goto state 8
	FunctionCall   goto state 85
	Exp2           goto state 92
	Identifier     goto state 87

State 75

	Exp1 -> Exp1 '/' . Exp2                             (rule 53)

	'('            shift, and enter state 88
	L_integ        shift, and enter state 2
	L_ident        shift, and enter state 10

	Integer        goto state 35
	Ident          goto state 8
	FunctionCall   goto state 85
	Exp2           goto state 91
	Identifier     goto state 87

State 76

	BExp1 -> Exp ComparisonOperator . Exp               (rule 62)

	'('            shift, and enter state 88
	L_integ        shift, and enter state 2
	L_ident        shift, and enter state 10

	Integer        goto state 35
	Ident          goto state 8
	FunctionCall   goto state 85
	Exp            goto state 90
	Exp1           goto state 39
	Exp2           goto state 40
	Identifier     goto state 87

State 77

	Exp -> Exp '+' . Exp1                               (rule 49)

	'('            shift, and enter state 88
	L_integ        shift, and enter state 2
	L_ident        shift, and enter state 10

	Integer        goto state 35
	Ident          goto state 8
	FunctionCall   goto state 85
	Exp1           goto state 89
	Exp2           goto state 40
	Identifier     goto state 87

State 78

	Exp -> Exp '-' . Exp1                               (rule 50)

	'('            shift, and enter state 88
	L_integ        shift, and enter state 2
	L_ident        shift, and enter state 10

	Integer        goto state 35
	Ident          goto state 8
	FunctionCall   goto state 85
	Exp1           goto state 86
	Exp2           goto state 40
	Identifier     goto state 87

State 79

	ComparisonOperator -> '<' .                         (rule 88)

	'('            reduce using rule 88
	L_integ        reduce using rule 88
	L_ident        reduce using rule 88


State 80

	ComparisonOperator -> '==' .                        (rule 89)

	'('            reduce using rule 89
	L_integ        reduce using rule 89
	L_ident        reduce using rule 89


State 81

	ComparisonOperator -> '>' .                         (rule 87)

	'('            reduce using rule 87
	L_integ        reduce using rule 87
	L_ident        reduce using rule 87


State 82

	Decl -> Type Identifier '=' Expression ';' .        (rule 7)

	';'            reduce using rule 7
	'bool'         reduce using rule 7
	'const'        reduce using rule 7
	'int'          reduce using rule 7
	'main'         reduce using rule 7
	'void'         reduce using rule 7


State 83

	Decl -> 'const' Type Identifier '=' Expression . ';'    (rule 8)

	';'            shift, and enter state 84


State 84

	Decl -> 'const' Type Identifier '=' Expression ';' .    (rule 8)

	';'            reduce using rule 8
	'bool'         reduce using rule 8
	'const'        reduce using rule 8
	'int'          reduce using rule 8
	'main'         reduce using rule 8
	'void'         reduce using rule 8


State 85

	Exp2 -> FunctionCall .                              (rule 55)

	')'            reduce using rule 55
	'*'            reduce using rule 55
	'+'            reduce using rule 55
	','            reduce using rule 55
	'-'            reduce using rule 55
	'/'            reduce using rule 55
	';'            reduce using rule 55
	'<'            reduce using rule 55
	'=='           reduce using rule 55
	'>'            reduce using rule 55


State 86

	Exp -> Exp '-' Exp1 .                               (rule 50)
	Exp1 -> Exp1 . '*' Exp2                             (rule 52)
	Exp1 -> Exp1 . '/' Exp2                             (rule 53)

	')'            reduce using rule 50
	'*'            shift, and enter state 74
	'+'            reduce using rule 50
	','            reduce using rule 50
	'-'            reduce using rule 50
	'/'            shift, and enter state 75
	';'            reduce using rule 50
	'<'            reduce using rule 50
	'=='           reduce using rule 50
	'>'            reduce using rule 50


State 87

	FunctionCall -> Identifier . '(' ListCallArgs ')'    (rule 20)
	Exp2 -> Identifier .                                (rule 56)

	'('            shift, and enter state 73
	')'            reduce using rule 56
	'*'            reduce using rule 56
	'+'            reduce using rule 56
	','            reduce using rule 56
	'-'            reduce using rule 56
	'/'            reduce using rule 56
	';'            reduce using rule 56
	'<'            reduce using rule 56
	'=='           reduce using rule 56
	'>'            reduce using rule 56


State 88

	Exp2 -> '(' . Exp ')'                               (rule 58)

	'('            shift, and enter state 88
	L_integ        shift, and enter state 2
	L_ident        shift, and enter state 10

	Integer        goto state 35
	Ident          goto state 8
	FunctionCall   goto state 85
	Exp            goto state 135
	Exp1           goto state 39
	Exp2           goto state 40
	Identifier     goto state 87

State 89

	Exp -> Exp '+' Exp1 .                               (rule 49)
	Exp1 -> Exp1 . '*' Exp2                             (rule 52)
	Exp1 -> Exp1 . '/' Exp2                             (rule 53)

	')'            reduce using rule 49
	'*'            shift, and enter state 74
	'+'            reduce using rule 49
	','            reduce using rule 49
	'-'            reduce using rule 49
	'/'            shift, and enter state 75
	';'            reduce using rule 49
	'<'            reduce using rule 49
	'=='           reduce using rule 49
	'>'            reduce using rule 49


State 90

	Exp -> Exp . '+' Exp1                               (rule 49)
	Exp -> Exp . '-' Exp1                               (rule 50)
	BExp1 -> Exp ComparisonOperator Exp .               (rule 62)

	')'            reduce using rule 62
	'+'            shift, and enter state 77
	','            reduce using rule 62
	'-'            shift, and enter state 78
	';'            reduce using rule 62


State 91

	Exp1 -> Exp1 '/' Exp2 .                             (rule 53)

	')'            reduce using rule 53
	'*'            reduce using rule 53
	'+'            reduce using rule 53
	','            reduce using rule 53
	'-'            reduce using rule 53
	'/'            reduce using rule 53
	';'            reduce using rule 53
	'<'            reduce using rule 53
	'=='           reduce using rule 53
	'>'            reduce using rule 53


State 92

	Exp1 -> Exp1 '*' Exp2 .                             (rule 52)

	')'            reduce using rule 52
	'*'            reduce using rule 52
	'+'            reduce using rule 52
	','            reduce using rule 52
	'-'            reduce using rule 52
	'/'            reduce using rule 52
	';'            reduce using rule 52
	'<'            reduce using rule 52
	'=='           reduce using rule 52
	'>'            reduce using rule 52


State 93

	ListCallArgs -> CallArgs .                          (rule 24)
	ListCallArgs -> CallArgs . ',' ListCallArgs         (rule 25)

	')'            reduce using rule 24
	','            shift, and enter state 134


State 94

	FunctionCall -> Identifier '(' ListCallArgs . ')'    (rule 20)

	')'            shift, and enter state 133


State 95

	CallArgs -> Expression .                            (rule 21)

	')'            reduce using rule 21
	','            reduce using rule 21


State 96

	BExp -> '(' BExp ')' . LogicalOperator '(' BExp ')'    (rule 59)
	BExp2 -> '(' BExp ')' .                             (rule 68)

	'&&'           shift, and enter state 131
	')'            reduce using rule 68
	','            reduce using rule 68
	';'            reduce using rule 68
	'||'           shift, and enter state 132

	LogicalOperatorgoto state 130

State 97

	Exp2 -> '(' Exp ')' .                               (rule 58)

	')'            reduce using rule 58
	'*'            reduce using rule 58
	'+'            reduce using rule 58
	','            reduce using rule 58
	'-'            reduce using rule 58
	'/'            reduce using rule 58
	';'            reduce using rule 58
	'<'            reduce using rule 58
	'=='           reduce using rule 58
	'>'            reduce using rule 58


State 98

	Exp -> Exp . '+' Exp1                               (rule 49)
	Exp -> Exp . '-' Exp1                               (rule 50)
	BExp1 -> Exp . ComparisonOperator Exp               (rule 62)

	'+'            shift, and enter state 77
	'-'            shift, and enter state 78
	'<'            shift, and enter state 79
	'=='           shift, and enter state 80
	'>'            shift, and enter state 81

	ComparisonOperatorgoto state 76

State 99

	BExp1 -> 'not' '(' BExp . ')'                       (rule 61)

	')'            shift, and enter state 129


State 100

	FunDec -> Type Identifier '(' ListArguments ')' . RBlock    (rule 18)

	'{'            shift, and enter state 128

	RBlock         goto state 127

State 101

	Stt -> 'while' '(' . BExp ')' Block                 (rule 37)

	'('            shift, and enter state 45
	'false'        shift, and enter state 46
	'not'          shift, and enter state 47
	'true'         shift, and enter state 48
	L_integ        shift, and enter state 2
	L_ident        shift, and enter state 10

	Integer        goto state 35
	Ident          goto state 8
	FunctionCall   goto state 36
	Exp            goto state 98
	Exp1           goto state 39
	Exp2           goto state 40
	BExp           goto state 126
	BExp1          goto state 42
	BExp2          goto state 43
	Identifier     goto state 44

State 102

	Stt -> 'if (' BExp . ')' Block ListEIf 'else' Block    (rule 40)

	')'            shift, and enter state 125


State 103

	Stt -> 'guard' '(' . ListIdentifier ')' 'in' Block    (rule 39)

	')'            reduce using rule 44
	L_ident        shift, and enter state 10

	Ident          goto state 8
	ListIdentifier goto state 123
	Identifier     goto state 124

State 104

	Stt -> 'for' '(' . Decl ';' BExp ';' Assignment ')' Block    (rule 38)

	'bool'         shift, and enter state 14
	'const'        shift, and enter state 15
	'int'          shift, and enter state 16

	Decl           goto state 122
	Type           goto state 13

State 105

	Assignment -> Identifier ArAssign . Expression      (rule 70)

	'('            shift, and enter state 45
	'false'        shift, and enter state 46
	'not'          shift, and enter state 47
	'true'         shift, and enter state 48
	L_integ        shift, and enter state 2
	L_ident        shift, and enter state 10

	Integer        goto state 35
	Ident          goto state 8
	FunctionCall   goto state 36
	Expression     goto state 121
	Exp            goto state 38
	Exp1           goto state 39
	Exp2           goto state 40
	BExp           goto state 41
	BExp1          goto state 42
	BExp2          goto state 43
	Identifier     goto state 44

State 106

	Assignment -> Identifier IncDec .                   (rule 71)

	')'            reduce using rule 71
	';'            reduce using rule 71


State 107

	ArAssign -> '*=' .                                  (rule 83)

	'('            reduce using rule 83
	'false'        reduce using rule 83
	'not'          reduce using rule 83
	'true'         reduce using rule 83
	L_integ        reduce using rule 83
	L_ident        reduce using rule 83


State 108

	IncDec -> '++' .                                    (rule 85)

	')'            reduce using rule 85
	';'            reduce using rule 85


State 109

	ArAssign -> '+=' .                                  (rule 81)

	'('            reduce using rule 81
	'false'        reduce using rule 81
	'not'          reduce using rule 81
	'true'         reduce using rule 81
	L_integ        reduce using rule 81
	L_ident        reduce using rule 81


State 110

	IncDec -> '--' .                                    (rule 86)

	')'            reduce using rule 86
	';'            reduce using rule 86


State 111

	ArAssign -> '-=' .                                  (rule 82)

	'('            reduce using rule 82
	'false'        reduce using rule 82
	'not'          reduce using rule 82
	'true'         reduce using rule 82
	L_integ        reduce using rule 82
	L_ident        reduce using rule 82


State 112

	ArAssign -> '/=' .                                  (rule 84)

	'('            reduce using rule 84
	'false'        reduce using rule 84
	'not'          reduce using rule 84
	'true'         reduce using rule 84
	L_integ        reduce using rule 84
	L_ident        reduce using rule 84


State 113

	Assignment -> Identifier '=' . Expression           (rule 69)

	'('            shift, and enter state 45
	'false'        shift, and enter state 46
	'not'          shift, and enter state 47
	'true'         shift, and enter state 48
	L_integ        shift, and enter state 2
	L_ident        shift, and enter state 10

	Integer        goto state 35
	Ident          goto state 8
	FunctionCall   goto state 36
	Expression     goto state 120
	Exp            goto state 38
	Exp1           goto state 39
	Exp2           goto state 40
	BExp           goto state 41
	BExp1          goto state 42
	BExp2          goto state 43
	Identifier     goto state 44

State 114

	Statement -> St ';' .                               (rule 29)

	'('            reduce using rule 29
	'bool'         reduce using rule 29
	'const'        reduce using rule 29
	'false'        reduce using rule 29
	'for'          reduce using rule 29
	'guard'        reduce using rule 29
	'if ('         reduce using rule 29
	'int'          reduce using rule 29
	'not'          reduce using rule 29
	'return'       reduce using rule 29
	'true'         reduce using rule 29
	'while'        reduce using rule 29
	'}'            reduce using rule 29
	L_integ        reduce using rule 29
	L_ident        reduce using rule 29


State 115

	Arguments -> Type Identifier .                      (rule 22)

	')'            reduce using rule 22
	','            reduce using rule 22


State 116

	ProcDec -> 'void' Identifier '(' ListArguments ')' . Block    (rule 19)

	'{'            shift, and enter state 29

	Block          goto state 119

State 117

	ListArguments -> Arguments ',' . ListArguments      (rule 28)

	')'            reduce using rule 26
	'bool'         shift, and enter state 14
	'int'          shift, and enter state 16

	Arguments      goto state 53
	ListArguments  goto state 118
	Type           goto state 55

State 118

	ListArguments -> Arguments ',' ListArguments .      (rule 28)

	')'            reduce using rule 28


State 119

	ProcDec -> 'void' Identifier '(' ListArguments ')' Block .    (rule 19)

	'bool'         reduce using rule 19
	'int'          reduce using rule 19
	'main'         reduce using rule 19
	'void'         reduce using rule 19


State 120

	Assignment -> Identifier '=' Expression .           (rule 69)

	')'            reduce using rule 69
	';'            reduce using rule 69


State 121

	Assignment -> Identifier ArAssign Expression .      (rule 70)

	')'            reduce using rule 70
	';'            reduce using rule 70


State 122

	Stt -> 'for' '(' Decl . ';' BExp ';' Assignment ')' Block    (rule 38)

	';'            shift, and enter state 143


State 123

	Stt -> 'guard' '(' ListIdentifier . ')' 'in' Block    (rule 39)

	')'            shift, and enter state 142


State 124

	ListIdentifier -> Identifier .                      (rule 45)
	ListIdentifier -> Identifier . ',' ListIdentifier    (rule 46)

	')'            reduce using rule 45
	','            shift, and enter state 141


State 125

	Stt -> 'if (' BExp ')' . Block ListEIf 'else' Block    (rule 40)

	'{'            shift, and enter state 29

	Block          goto state 140

State 126

	Stt -> 'while' '(' BExp . ')' Block                 (rule 37)

	')'            shift, and enter state 139


State 127

	FunDec -> Type Identifier '(' ListArguments ')' RBlock .    (rule 18)

	'bool'         reduce using rule 18
	'int'          reduce using rule 18
	'main'         reduce using rule 18
	'void'         reduce using rule 18


State 128

	RBlock -> '{' . ListStatement 'return' Expression ';' '}'    (rule 5)

	'('            reduce using rule 31
	'bool'         reduce using rule 31
	'const'        reduce using rule 31
	'false'        reduce using rule 31
	'for'          reduce using rule 31
	'guard'        reduce using rule 31
	'if ('         reduce using rule 31
	'int'          reduce using rule 31
	'not'          reduce using rule 31
	'return'       reduce using rule 31
	'true'         reduce using rule 31
	'while'        reduce using rule 31
	L_integ        reduce using rule 31
	L_ident        reduce using rule 31

	ListStatement  goto state 138

State 129

	BExp1 -> 'not' '(' BExp ')' .                       (rule 61)

	')'            reduce using rule 61
	','            reduce using rule 61
	';'            reduce using rule 61


State 130

	BExp -> '(' BExp ')' LogicalOperator . '(' BExp ')'    (rule 59)

	'('            shift, and enter state 137


State 131

	LogicalOperator -> '&&' .                           (rule 90)

	'('            reduce using rule 90


State 132

	LogicalOperator -> '||' .                           (rule 91)

	'('            reduce using rule 91


State 133

	FunctionCall -> Identifier '(' ListCallArgs ')' .    (rule 20)

	')'            reduce using rule 20
	'*'            reduce using rule 20
	'+'            reduce using rule 20
	','            reduce using rule 20
	'-'            reduce using rule 20
	'/'            reduce using rule 20
	';'            reduce using rule 20
	'<'            reduce using rule 20
	'=='           reduce using rule 20
	'>'            reduce using rule 20


State 134

	ListCallArgs -> CallArgs ',' . ListCallArgs         (rule 25)

	'('            shift, and enter state 45
	')'            reduce using rule 23
	'false'        shift, and enter state 46
	'not'          shift, and enter state 47
	'true'         shift, and enter state 48
	L_integ        shift, and enter state 2
	L_ident        shift, and enter state 10

	Integer        goto state 35
	Ident          goto state 8
	FunctionCall   goto state 36
	CallArgs       goto state 93
	ListCallArgs   goto state 136
	Expression     goto state 95
	Exp            goto state 38
	Exp1           goto state 39
	Exp2           goto state 40
	BExp           goto state 41
	BExp1          goto state 42
	BExp2          goto state 43
	Identifier     goto state 44

State 135

	Exp -> Exp . '+' Exp1                               (rule 49)
	Exp -> Exp . '-' Exp1                               (rule 50)
	Exp2 -> '(' Exp . ')'                               (rule 58)

	')'            shift, and enter state 97
	'+'            shift, and enter state 77
	'-'            shift, and enter state 78


State 136

	ListCallArgs -> CallArgs ',' ListCallArgs .         (rule 25)

	')'            reduce using rule 25


State 137

	BExp -> '(' BExp ')' LogicalOperator '(' . BExp ')'    (rule 59)

	'('            shift, and enter state 45
	'false'        shift, and enter state 46
	'not'          shift, and enter state 47
	'true'         shift, and enter state 48
	L_integ        shift, and enter state 2
	L_ident        shift, and enter state 10

	Integer        goto state 35
	Ident          goto state 8
	FunctionCall   goto state 36
	Exp            goto state 98
	Exp1           goto state 39
	Exp2           goto state 40
	BExp           goto state 150
	BExp1          goto state 42
	BExp2          goto state 43
	Identifier     goto state 44

State 138

	RBlock -> '{' ListStatement . 'return' Expression ';' '}'    (rule 5)
	ListStatement -> ListStatement . Statement          (rule 32)

	'('            shift, and enter state 45
	'bool'         shift, and enter state 14
	'const'        shift, and enter state 15
	'false'        shift, and enter state 46
	'for'          shift, and enter state 64
	'guard'        shift, and enter state 65
	'if ('         shift, and enter state 66
	'int'          shift, and enter state 16
	'not'          shift, and enter state 47
	'return'       shift, and enter state 149
	'true'         shift, and enter state 48
	'while'        shift, and enter state 67
	L_integ        shift, and enter state 2
	L_ident        shift, and enter state 10

	Integer        goto state 35
	Ident          goto state 8
	Decl           goto state 56
	FunctionCall   goto state 57
	Statement      goto state 58
	St             goto state 59
	Stt            goto state 60
	Expression     goto state 61
	Exp            goto state 38
	Exp1           goto state 39
	Exp2           goto state 40
	BExp           goto state 41
	BExp1          goto state 42
	BExp2          goto state 43
	Assignment     goto state 62
	Type           goto state 13
	Identifier     goto state 63

State 139

	Stt -> 'while' '(' BExp ')' . Block                 (rule 37)

	'{'            shift, and enter state 29

	Block          goto state 148

State 140

	Stt -> 'if (' BExp ')' Block . ListEIf 'else' Block    (rule 40)

	'else'         reduce using rule 42
	'else if ('    reduce using rule 42

	ListEIf        goto state 147

State 141

	ListIdentifier -> Identifier ',' . ListIdentifier    (rule 46)

	')'            reduce using rule 44
	L_ident        shift, and enter state 10

	Ident          goto state 8
	ListIdentifier goto state 146
	Identifier     goto state 124

State 142

	Stt -> 'guard' '(' ListIdentifier ')' . 'in' Block    (rule 39)

	'in'           shift, and enter state 145


State 143

	Stt -> 'for' '(' Decl ';' . BExp ';' Assignment ')' Block    (rule 38)

	'('            shift, and enter state 45
	'false'        shift, and enter state 46
	'not'          shift, and enter state 47
	'true'         shift, and enter state 48
	L_integ        shift, and enter state 2
	L_ident        shift, and enter state 10

	Integer        goto state 35
	Ident          goto state 8
	FunctionCall   goto state 36
	Exp            goto state 98
	Exp1           goto state 39
	Exp2           goto state 40
	BExp           goto state 144
	BExp1          goto state 42
	BExp2          goto state 43
	Identifier     goto state 44

State 144

	Stt -> 'for' '(' Decl ';' BExp . ';' Assignment ')' Block    (rule 38)

	';'            shift, and enter state 157


State 145

	Stt -> 'guard' '(' ListIdentifier ')' 'in' . Block    (rule 39)

	'{'            shift, and enter state 29

	Block          goto state 156

State 146

	ListIdentifier -> Identifier ',' ListIdentifier .    (rule 46)

	')'            reduce using rule 46


State 147

	Stt -> 'if (' BExp ')' Block ListEIf . 'else' Block    (rule 40)
	ListEIf -> ListEIf . EIf                            (rule 43)

	'else'         shift, and enter state 154
	'else if ('    shift, and enter state 155

	EIf            goto state 153

State 148

	Stt -> 'while' '(' BExp ')' Block .                 (rule 37)

	'('            reduce using rule 37
	'bool'         reduce using rule 37
	'const'        reduce using rule 37
	'false'        reduce using rule 37
	'for'          reduce using rule 37
	'guard'        reduce using rule 37
	'if ('         reduce using rule 37
	'int'          reduce using rule 37
	'not'          reduce using rule 37
	'return'       reduce using rule 37
	'true'         reduce using rule 37
	'while'        reduce using rule 37
	'}'            reduce using rule 37
	L_integ        reduce using rule 37
	L_ident        reduce using rule 37


State 149

	RBlock -> '{' ListStatement 'return' . Expression ';' '}'    (rule 5)

	'('            shift, and enter state 45
	'false'        shift, and enter state 46
	'not'          shift, and enter state 47
	'true'         shift, and enter state 48
	L_integ        shift, and enter state 2
	L_ident        shift, and enter state 10

	Integer        goto state 35
	Ident          goto state 8
	FunctionCall   goto state 36
	Expression     goto state 152
	Exp            goto state 38
	Exp1           goto state 39
	Exp2           goto state 40
	BExp           goto state 41
	BExp1          goto state 42
	BExp2          goto state 43
	Identifier     goto state 44

State 150

	BExp -> '(' BExp ')' LogicalOperator '(' BExp . ')'    (rule 59)

	')'            shift, and enter state 151


State 151

	BExp -> '(' BExp ')' LogicalOperator '(' BExp ')' .    (rule 59)

	')'            reduce using rule 59
	','            reduce using rule 59
	';'            reduce using rule 59


State 152

	RBlock -> '{' ListStatement 'return' Expression . ';' '}'    (rule 5)

	';'            shift, and enter state 162


State 153

	ListEIf -> ListEIf EIf .                            (rule 43)

	'else'         reduce using rule 43
	'else if ('    reduce using rule 43


State 154

	Stt -> 'if (' BExp ')' Block ListEIf 'else' . Block    (rule 40)

	'{'            shift, and enter state 29

	Block          goto state 161

State 155

	EIf -> 'else if (' . BExp ')' Block                 (rule 41)

	'('            shift, and enter state 45
	'false'        shift, and enter state 46
	'not'          shift, and enter state 47
	'true'         shift, and enter state 48
	L_integ        shift, and enter state 2
	L_ident        shift, and enter state 10

	Integer        goto state 35
	Ident          goto state 8
	FunctionCall   goto state 36
	Exp            goto state 98
	Exp1           goto state 39
	Exp2           goto state 40
	BExp           goto state 160
	BExp1          goto state 42
	BExp2          goto state 43
	Identifier     goto state 44

State 156

	Stt -> 'guard' '(' ListIdentifier ')' 'in' Block .    (rule 39)

	'('            reduce using rule 39
	'bool'         reduce using rule 39
	'const'        reduce using rule 39
	'false'        reduce using rule 39
	'for'          reduce using rule 39
	'guard'        reduce using rule 39
	'if ('         reduce using rule 39
	'int'          reduce using rule 39
	'not'          reduce using rule 39
	'return'       reduce using rule 39
	'true'         reduce using rule 39
	'while'        reduce using rule 39
	'}'            reduce using rule 39
	L_integ        reduce using rule 39
	L_ident        reduce using rule 39


State 157

	Stt -> 'for' '(' Decl ';' BExp ';' . Assignment ')' Block    (rule 38)

	L_ident        shift, and enter state 10

	Ident          goto state 8
	Assignment     goto state 158
	Identifier     goto state 159

State 158

	Stt -> 'for' '(' Decl ';' BExp ';' Assignment . ')' Block    (rule 38)

	')'            shift, and enter state 165


State 159

	Assignment -> Identifier . '=' Expression           (rule 69)
	Assignment -> Identifier . ArAssign Expression      (rule 70)
	Assignment -> Identifier . IncDec                   (rule 71)

	'*='           shift, and enter state 107
	'++'           shift, and enter state 108
	'+='           shift, and enter state 109
	'--'           shift, and enter state 110
	'-='           shift, and enter state 111
	'/='           shift, and enter state 112
	'='            shift, and enter state 113

	ArAssign       goto state 105
	IncDec         goto state 106

State 160

	EIf -> 'else if (' BExp . ')' Block                 (rule 41)

	')'            shift, and enter state 164


State 161

	Stt -> 'if (' BExp ')' Block ListEIf 'else' Block .    (rule 40)

	'('            reduce using rule 40
	'bool'         reduce using rule 40
	'const'        reduce using rule 40
	'false'        reduce using rule 40
	'for'          reduce using rule 40
	'guard'        reduce using rule 40
	'if ('         reduce using rule 40
	'int'          reduce using rule 40
	'not'          reduce using rule 40
	'return'       reduce using rule 40
	'true'         reduce using rule 40
	'while'        reduce using rule 40
	'}'            reduce using rule 40
	L_integ        reduce using rule 40
	L_ident        reduce using rule 40


State 162

	RBlock -> '{' ListStatement 'return' Expression ';' . '}'    (rule 5)

	'}'            shift, and enter state 163


State 163

	RBlock -> '{' ListStatement 'return' Expression ';' '}' .    (rule 5)

	'bool'         reduce using rule 5
	'int'          reduce using rule 5
	'main'         reduce using rule 5
	'void'         reduce using rule 5


State 164

	EIf -> 'else if (' BExp ')' . Block                 (rule 41)

	'{'            shift, and enter state 29

	Block          goto state 167

State 165

	Stt -> 'for' '(' Decl ';' BExp ';' Assignment ')' . Block    (rule 38)

	'{'            shift, and enter state 29

	Block          goto state 166

State 166

	Stt -> 'for' '(' Decl ';' BExp ';' Assignment ')' Block .    (rule 38)

	'('            reduce using rule 38
	'bool'         reduce using rule 38
	'const'        reduce using rule 38
	'false'        reduce using rule 38
	'for'          reduce using rule 38
	'guard'        reduce using rule 38
	'if ('         reduce using rule 38
	'int'          reduce using rule 38
	'not'          reduce using rule 38
	'return'       reduce using rule 38
	'true'         reduce using rule 38
	'while'        reduce using rule 38
	'}'            reduce using rule 38
	L_integ        reduce using rule 38
	L_ident        reduce using rule 38


State 167

	EIf -> 'else if (' BExp ')' Block .                 (rule 41)

	'else'         reduce using rule 41
	'else if ('    reduce using rule 41


-----------------------------------------------------------------------------
Grammar Totals
-----------------------------------------------------------------------------
Number of rules: 92
Number of terminals: 43
Number of non-terminals: 41
Number of states: 168
